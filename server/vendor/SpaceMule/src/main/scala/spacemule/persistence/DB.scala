/*
 * To change this template, choose Tools | Templates
 * and open the template in the editor.
 */

package spacemule.persistence

import exceptions.LoadInFileException
import java.text.SimpleDateFormat
import java.util.Calendar
import java.util.Date
import scala.collection.mutable.ListBuffer
import java.io.{FileWriter, File}
import spacemule.helpers.Converters._
import java.sql._
import spacemule.helpers.JRuby._

object DB {
  // Set this environment variable to "1" to keep tmp files generated by load
  // data infile.
  val KeepTmpFilesEnvVar = "KEEP_BULKSQL_TMP"
  private[this] val keepTmpFiles = System.getenv(KeepTmpFilesEnvVar) == "1"

  /**
   * Use this instead of NULL if you're using loadInFile()
   */
  val loadInFileNull = "\\N"

  // Returns pseudo-unique string batch id.
  def batchId: String = "%s%s".format(
    Thread.currentThread().getId.toString(Character.MAX_RADIX),
    System.currentTimeMillis().toString(Character.MAX_RADIX)
  )

  /**
   * Format date to db string.
   */
  def date(date: Date): String =
    new SimpleDateFormat("yyyy-MM-dd HH:mm:ss").format(date)

  def date(calendar: Calendar): String = date(calendar.getTime)
  def date(calendar: Option[Calendar]): String = calendar match {
    case Some(cal) => date(cal)
    case None | null => loadInFileNull
  }

  def connection: Connection = RModule("ActiveRecord").
    getClass("Base").
    callMethod("connection").
    call("jdbc_connection").
    unwrap[Connection]

  def exec(sql: String): Int = {
    val statement = connection.createStatement
    try {
      statement.executeUpdate(sql)
    }
    finally {
      statement.close()
    }
  }

  def insert(sql: String, params: Seq[String]): Int = {
    val statement = connection.prepareStatement(
      sql, Statement.RETURN_GENERATED_KEYS
    )
    try {
      params.view.zipWithIndex.foreach { case (param, index) =>
        statement.setString(index + 1, param)
      }
      statement.executeUpdate()

      // Return generated id.
      val resultSet = statement.getGeneratedKeys()
      try {
        if (resultSet != null && resultSet.next()) resultSet.getInt(1)
        else 0
      }
      finally {
        resultSet.close()
      }
    }
    finally {
      statement.close()
    }
  }

  /**
   * Loads data from values into table ultra quickly fast.
   *
   * See http://dev.mysql.com/doc/refman/5.1/en/load-data.html for
   * information how to avoid being sql injected by using this.
   */
  def loadInFile(
    tableName: String, columns: String, values: Seq[Seq[Any]],
    batchId: Option[String]
  ) = {
    if (values.isEmpty)
      throw new IllegalArgumentException(
        "Cannot save empty values list to table '"+tableName+"' with columns '"+
          columns+"'!"
      )
    
    val file = File.createTempFile("bulk_sql-scala-%s".format(tableName), null)
    file.setReadable(true, false); // Allow mysql to read that file.

    // Win32 support. Replace backslashes with double backslashes, because
    // mysql does its own backslash escaping, so we actually need to pass
    // "C:/tmp/foo" instead of "c:\tmp\foo". Thank god windows at least supports
    // '/' as path separator.
    val filename = file.getAbsolutePath.replace('\\', '/')
    // Define the query we are going to execute
    val cols = batchId match {
      case Some(id) => columns+", `batch_id`"
      case None => columns
    }
    val statementText =
      "LOAD DATA INFILE '"+filename+"' INTO TABLE `"+tableName+"` ("+cols+")"

    // Iterate over map and create tab-text string
    writeValues(file, values, batchId)

    // First create a statement off the connection
    val statement = connection.createStatement.asInstanceOf[
      com.mysql.jdbc.Statement
    ]

    try {
      // Execute the load infile
      statement.execute(statementText);
    }
    catch {
      case ex: Exception => throw new LoadInFileException(
        file.getAbsolutePath, tableName, cols, ex
      )
    }
    finally {
      statement.close()
      if (! keepTmpFiles) file.delete()
    }
  }

  private[this] def writeValues(
    file: File, values: Seq[Seq[Any]], optBatchId: Option[String]
  ) {
    val writer = new FileWriter(file)
    val rowsIterator = values.iterator
    val batchId = optBatchId match {
      case Some(id) => id
      case None => null
    }

    while (rowsIterator.hasNext) {
      val iterator = rowsIterator.next().iterator
      var first = true

      while (iterator.hasNext) {
        if (first) first = false else writer.append('\t')
        writer.append(iterator.next().toString)
      }

      if (batchId != null) {
        writer.append('\t')
        writer.append(batchId)
      }
      writer.append('\n')
    }

    writer.close()
  }

  def query[T](sql: String)(f: ResultSet => T): T = {
    // Configure to be Read Only
    val statement = connection.createStatement(
      ResultSet.TYPE_FORWARD_ONLY, ResultSet.CONCUR_READ_ONLY
    )

    val rs = statement.executeQuery(sql)
    try {
      f(rs)
    }
    finally {
      rs.close()
      statement.close()
    }
  }

  def getOne[T](sql: String): Option[T] = {
    query(sql) { resultSet =>
      if (resultSet.first)
        Some(resultSet.getObject(1).asInstanceOf[T])
      else
        None
    }
  }

  def getCol[T](sql: String): collection.Seq[T] = {
    query(sql) { resultSet =>
      var list = ListBuffer.empty[T]
      while (resultSet.next) {
        list += resultSet.getObject(1).asInstanceOf[T]
      }

      list
    }
  }
}
