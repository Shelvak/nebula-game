package utils.pool.impl
{
   import mx.logging.ILogger;

   import utils.Objects;
   import utils.logging.IMethodLoggerFactory;
   import utils.logging.Log;
   import utils.pool.BaseObjectPool;
   import utils.pool.IPoolableObjectFactory;


   /**
    * A simple, stack-based <code>IObjectPool</code> implementation.
    *
    * <p>
    * Given a <code>IPoolableObjectFactory</code>, this class will maintain a simple pool of instances.
    * No limits are enforced on idle instances in the pool or active instances created by the pool.
    * <p>
    */
   public class StackObjectPool extends BaseObjectPool
   {
      private const loggerFactory: IMethodLoggerFactory = Log.getMethodLoggerFactory(StackObjectPool);

      private var _pool: Array;
      private var _numActive: int;

      private var _factory: IPoolableObjectFactory;
      /**
       * <code>IPoolableObjectFactory</code> used by this pool to create and manage object instances.
       */
      public function get factory(): IPoolableObjectFactory {
         return _factory;
      }

      /**
       * Create new pool that will use given factory.
       *
       * @param factory the <code>IPoolableObjectFactory</code> used to populate the pool. <b>Not null</b>.
       */
      public function StackObjectPool(factory: IPoolableObjectFactory) {
         super();
         _factory = Objects.paramNotNull("factory", factory);
         _numActive = 0;
         _pool = new Array();
      }

      /**
       * Borrows an object from the pool. If there are idle instances available on the stack, the top
       * element of the stack is popped to activate, validate and return to the client. If there
       * are no idle instances available, the <code>makeObject()</code> method of the pool's
       * <code>IPoolableObjectFactory</code> is invoked to create a new instance.
       *
       * <p>All instances are activated (with <code>IPoolableObjectFactory.activateObject()</code>) and
       * validated (with <code>IPoolableObjectFactory.validateObject()</code>) before being returned to the
       * client. If validation fails or an error occurs activating or validating an instance popped from the
       * idle instance stack, the failing instance is
       * destroyed (with <code>IPoolableObjectFactory.destroyObject()</code>) and the next instance on the
       * stack is popped, validated and activated. This process continues until either the stack is empty or
       * an instance passes validation. If the stack is empty on activation or it does not contain any valid
       * instances, the factory's <code>makeObject()</code> method is used to create a new instance.  If a
       * <code>null</code> is returned by the factory or the created instance either raises an error on
       * activation or fails validation, <code>Error</code> is thrown. Errors thrown by
       * <code>makeObject()</code> are propagated to the caller; but errors generated by activation,
       * validation or destruction methods are swallowed silently.</p>
       *
       * @return an instance from the pool
       */
      public override function borrowObject(): Object {
         assertOpen();
         var obj: Object = null;
         var newlyCreated: Boolean = false;
         while (obj == null) {
            if (_pool.length > 0) {
               obj = _pool.pop();
            }
            else {
               obj = _factory.makeObject();
               newlyCreated = true;
               if (obj == null) {
                  throw new Error(
                     "IPoolableObjectFactory.makeObject() returned null"
                  );
               }
            }

            try {
               _factory.activateObject(obj);
               if (!_factory.validateObject(obj)) {
                  throw new Error(
                     "IPoolableObjectFactory.validateObject() failed (returned false)");
               }
            }
            catch (e: Error) {
               try {
                  _factory.destroyObject(obj);
               }
               // swallowed
               catch (e: Error) {
                  loggerFactory.getLogger("borrowObject").warn(
                     "Error destroying poolable object {0}. Newly created: {1}", obj,  newlyCreated);
               }
               finally {
                  obj = null;
               }
               if (newlyCreated) {
                  throw new Error(
                     "Could not create a validated object, cause: " + e.message
                  );
               }
            }
         }
         _numActive++;
         return obj;
      }

      /**
       * Returns an instance to the pool, pushing it on top of the idle instance stack after successful
       * validation and passivation. The returning instance is destroyed if any of the following are true:
       * <ul>
       *   <li>the pool is closed</li>
       *   <li>validation (with <code>IPoolableObjectFactory.validateObject()</code>) fails</li>
       *   <li>passivation (with <code>IPoolableObjectFactory.passivateObject()</code>) throws an error</li>
       * </ul>
       *
       * <p>Errors passivating or destroying instances are silently swallowed. Errors thrown on validation of
       * instances are propagated to the client.</p>
       *
       * @param obj instance to return to the pool. <b>Not null</b>.
       */
      public override function returnObject(obj: Object): void {
         Objects.paramNotNull("obj", obj);
         const logger:ILogger = loggerFactory.getLogger("returnObject");
         var success: Boolean = !closed;

         if (!_factory.validateObject(obj)) {
            success = false;
         }
         else {
            try {
               _factory.passivateObject(obj);
            }
            catch (e: Error) {
               logger.warn(
                  "error while passivating object {0}.\nError message: {1}", obj,  e.message);
               success = false;
            }
         }

         _numActive--;
         if (success) {
            _pool.push(obj);
         }
         else {
            try {
               _factory.destroyObject(obj);
            }
            // ignored
            catch (e: Error) {
               logger.warn(
                  "Error while destroying object {0}. \nError message: {1}", obj, e.message);
            }
         }
      }

      public override function invalidateObject(obj: Object): void {
         Objects.paramNotNull("obj", obj);
         _numActive--;
         _factory.destroyObject(obj);
      }

      public override function addObject(): void {
         assertOpen();
         var obj: Object = _factory.makeObject();
         if (!_factory.validateObject(obj)) {
            try {
               _factory.destroyObject(obj);
            }
            // ignored
            catch (e: Error) {
            }
         }
         else {
            _factory.passivateObject(obj);
            _pool.push(obj);
         }
      }

      /**
       * Clears any objects sitting idle in the pool. Silently swallows any errors thrown by
       * <code>IPoolableObjectFactory.destroyObject()</code>.
       */
      public override function clear(): void {
         for each (var obj: Object in _pool) {
            try {
               _factory.destroyObject(obj);
            }
            // ignore error, keep destroying the rest
            catch (e: Error) {
            }
         }
         _pool.splice(0, _pool.length);
      }

      /**
       * <p>Close this pool, and free any resources associated with it. Invokes <code>clear</code> to destroy
       * and remove instances in the pool.</p>
       *
       * <p>Calling <code>addObject</code> or <code>borrowObject</code> after invoking this method on a pool
       * will cause them to throw an <code>IllegalStateError</code>.</p>
       *
       * @see #clear()
       */
      public override function close(): void {
         super.close();
         clear();
      }

      public override function get numIdle(): int {
         return _pool.length;
      }

      public override function get numActive(): int {
         return _numActive;
      }
   }
}