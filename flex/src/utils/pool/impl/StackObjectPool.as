package utils.pool.impl
{
   import utils.Objects;
   import utils.pool.BaseObjectPool;
   import utils.pool.IPoolableObjectFactory;
   
   
   /**
    * A simple, stack-based <code>IObjectPool</code> implementation.
    * 
    * <p>
    * Given a <code>IPoolableObjectFactory</code>, this class will maintain a simple pool of instances.
    * No limits are enforced on idle instances in the pool or active instances created by the pool.
    * <p>
    */
   public class StackObjectPool extends BaseObjectPool
   {
      private var _pool:Array;
      private var _numActive:int;
      
      
      private var _factory:IPoolableObjectFactory;
      /**
       * <code>IPoolableObjectFactory</code> used by this pool to create and manage object instances.
       */
      public function get factory() : IPoolableObjectFactory
      {
         return _factory;
      }
      
      
      /**
       * Create new pool that will use given factory.
       * 
       * @param factory the <code>IPoolableObjectFactory</code> used to populate the pool. <b>Not null</b>.
       */
      public function StackObjectPool(factory:IPoolableObjectFactory)
      {
         super();
         _factory = Objects.paramNotNull("factory", factory);;
         _numActive = 0;
         _pool = new Array();
      }
      
      
      /**
       * Borrows an object from the pool. If there are idle instances available on the stack, the top
       * element of the stack is popped to activate, validate and return to the client. If there
       * are no idle instances available, the <code>makeObject()</code> method of the pool's
       * <code>IPoolableObjectFactory</code> is invoked to create a new instance.
       * 
       * <p>All instances are activated (with <code>IPoolableObjectFactory.activateObject()</code>) and
       * validated (with <code>IPoolableObjectFactory.validateObject()</code>) before being returned to the
       * client. If validation fails or an error occurs activating or validating an instance popped from the
       * idle instance stack, the failing instance is 
       * destroyed (with <code>IPoolableObjectFactory.destroyObject()</code>) and the next instance on the
       * stack is popped, validated and activated. This process continues until either the stack is empty or
       * an instance passes validation. If the stack is empty on activation or it does not contain any valid
       * instances, the factory's <code>makeObject()</code> method is used to create a new instance.  If a
       * <code>null</code> is returned by the factory or the created instance either raises an error on
       * activation or fails validation, <code>Error</code> is thrown. Errors thrown by
       * <code>makeObject()</code> are propagated to the caller; but errors generated by activation,
       * validation or destruction methods are swallowed silently.</p>
       * 
       * @return an instance from the pool
       */
      public override function borrowObject() : Object
      {
         assertOpen();
         var obj:Object = null;
         var newlyCreated:Boolean = false;
         while (obj == null)
         {
            if (_pool.length > 0)
            {
               obj = _pool.pop();
            }
            else 
            {
               obj = _factory.makeObject();
               newlyCreated = true;
               if (obj == null)
               {
                  throw new Error("IPoolableObjectFactory.makeObject() returned null");
               }
            }
            
            try
            {
               _factory.activateObject(obj);
               if (!_factory.validateObject(obj))
               {
                  throw new Error("IPoolableObjectFactory.validateObject() failed (returned false)");
               }
            }
            catch (e:Error)
            {
               try
               {
                  _factory.destroyObject(obj);
               }
               // swallowed
               catch (e:Error) {}
               finally
               {
                  obj = null;
               }
               if (newlyCreated)
               {
                  throw new Error("Could not create a validated object, cause: " + e.message);
               }
            }
         }
         _numActive++;
         return obj;
      }
      
      
      /**
       * Returns an instance to the pool, pushing it on top of the idle instance stack after successful
       * validation and passivation. The returning instance is destroyed if any of the following are true:
       * <ul>
       *   <li>the pool is closed</li>
       *   <li>validation (with <code>IPoolableObjectFactory.validateObject()</code>) fails</li>
       *   <li>passivation (with <code>IPoolableObjectFactory.passivateObject()</code>) throws an error</li>
       * </ul>
       * 
       * <p>Errors passivating or destroying instances are silently swallowed. Errors thrown on validation of
       * instances are propagated to the client.</p>
       * 
       * @param obj instance to return to the pool. <b>Not null</b>.
       */
      public override function returnObject(obj:Object) : void
      {
         Objects.paramNotNull("obj", obj);
         var success:Boolean = !closed;
         
         if (!_factory.validateObject(obj))
         {
            success = false;
         }
         else
         {
            try
            {
               _factory.passivateObject(obj);
            }
            catch (e:Error)
            {
               success = false;
            }
         }
         
         _numActive--;
         if (success)
         {
            _pool.push(obj);
         }
         else
         {
            try
            {
               _factory.destroyObject(obj);
            }
            // ignored
            catch (e:Error) {}
         }
      }
      
      
      public override function invalidateObject(obj:Object) : void
      {
         Objects.paramNotNull("obj", obj);
         _numActive--;
         _factory.destroyObject(obj);
      }
      
      
      public override function addObject() : void
      {
         assertOpen();
         var obj:Object = _factory.makeObject();
         if (!_factory.validateObject(obj))
         {
            try
            {
               _factory.destroyObject(obj);
            }
            // ignored
            catch (e:Error) {}
         }
         else
         {
            _factory.passivateObject(obj);
            _pool.push(obj);
         }
      }
      
      
      /**
       * Clears any objects sitting idle in the pool. Silently swallows any errors thrown by
       * <code>IPoolableObjectFactory.destroyObject()</code>.
       */
      public override function clear() : void
      {
         for each (var obj:Object in _pool)
         {
            try
            {
               _factory.destroyObject(obj);
            }
            // ignore error, keep destroying the rest
            catch (e:Error) {}
         }
         _pool.splice(0, _pool.length);
      }
      
      
      /**
       * <p>Close this pool, and free any resources associated with it. Invokes <code>clear</code> to destroy
       * and remove instances in the pool.</p>
       * 
       * <p>Calling <code>addObject</code> or <code>borrowObject</code> after invoking this method on a pool
       * will cause them to throw an <code>IllegalStateError</code>.</p>
       *
       * @see #clear()
       */
      public override function close() : void
      {
         super.close();
         clear();
      }
      
      
      public override function get numIdle() : int
      {
         return _pool.length;
      }
      
      
      public override function get numActive() : int
      {
         return _numActive;
      }
   }
}