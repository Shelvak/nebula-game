<?xml version="1.0" encoding="utf-8"?>
<base:BaseContainer xmlns:fx="http://ns.adobe.com/mxml/2009" 
                    xmlns:s="library://ns.adobe.com/flex/spark" 
                    xmlns:mx="library://ns.adobe.com/flex/halo"
                    xmlns:base="components.base.*"
                    xmlns:elements="components.buildingsidebar.*"
                    height="100%" width="100%" rollOver="basecontainer1_rollOverHandler(event)"
                    creationComplete="this_creationCompleteHandler(event)">
   
   <fx:Script>
      <![CDATA[
         import com.developmentarc.core.utils.EventBroker;
         
         import config.Config;
         
         import controllers.buildings.BuildingsCommand;
         import controllers.constructionqueues.ConstructionQueuesCommand;
         import controllers.objects.ObjectClass;
         import controllers.screens.MainAreaScreens;
         import controllers.screens.SidebarScreens;
         import controllers.ui.NavigationController;
         import controllers.units.UnitsCommand;
         
         import globalevents.GBuildingEvent;
         import globalevents.GBuildingMoveEvent;
         import globalevents.GObjectEvent;
         import globalevents.GPlanetEvent;
         import globalevents.GResourcesEvent;
         import globalevents.GScreenChangeEvent;
         import globalevents.GSelectConstructableEvent;
         
         import models.Owner;
         import models.building.Building;
         import models.building.BuildingBonuses;
         import models.building.BuildingType;
         import models.building.events.BuildingEvent;
         import models.constructionqueueentry.ConstructionQueueEntry;
         import models.parts.Upgradable;
         import models.parts.UpgradableType;
         import models.planet.Planet;
         import models.planet.PlanetObject;
         import models.resource.Resource;
         import models.resource.ResourceType;
         import models.solarsystem.MSSObject;
         import models.unit.Unit;
         
         import mx.collections.ArrayCollection;
         import mx.collections.ListCollectionView;
         import mx.core.ScrollPolicy;
         import mx.events.DragEvent;
         import mx.events.FlexEvent;
         import mx.managers.DragManager;
         
         import spark.components.Label;
         
         import utils.DateUtil;
         import utils.Localizer;
         import utils.ObjectStringsResolver;
         import utils.StringUtil;
         import utils.datastructures.Collections;
         
         public static const timeIconName: String = "time";
         
         
         [Bindable]
         private var waitingForApproval: Boolean = false;
         
         [Bindable]
         private var _buildingFacilities: ListCollectionView = new ListCollectionView ();
         
         [Bindable]
         public var armorText: String = null;
         [Bindable]
         public var energyText: String = null;
         [Bindable]
         public var constructionText: String = null;
         
         
         private var armorIndex: int = 0;
         private var energyIndex: int = 0;
         private var constructionIndex: int = 0;
         
         [Bindable]
         private var metalPrice: String;
         [Bindable]
         private var energyPrice: String;
         [Bindable]
         private var zetiumPrice: String;
         
         
         [Bindable]
         private var hasFacilities: Boolean;
         
         
         [Bindable]
         private var selectedBuilding: String = null;
         
         [Bindable]
         private var selectedFacility: Building = null;
         
         [Bindable]
         private var selectedConstructionModel: Building = null;
         
         private function prepare():void{
            armorBonus = 0;
            energyBonus = 0;
            constructionBonus = 0;
            setFacilities();
         }
         
         private function handleDemoChange(e: DemoChangedEvent): void
         {
            selectedBuilding = e.building;
            refreshPrice();
            dispatchBuildTimeChangeEvent();
            calculateResLeft()
         }
         
         private static const CONSTRUCTORS: Array = Config.getConstructors(ObjectClass.BUILDING);
         
         private function setFacilities(e: GPlanetEvent = null): void
         {
            if (ML.latestPlanet != null)
            {
               _buildingFacilities = Collections.filter(ML.latestPlanet.objects,
                  function (item: PlanetObject): Boolean
                  {
                     return item is Building && BuildingSidebar.CONSTRUCTORS.indexOf(Building(item).type) != -1 && 
                     Building(item).state != Building.INACTIVE && Building(item).upgradePart.level > 0 &&
                     Building(item).upgradePart.upgradeEndsAt == null;
                  });
               facilities.buildGaleryGrid(_buildingFacilities);
               refreshFacilities();
               refreshConstructableStates();
            }
         }
         
         private function refreshFacilities(e: GPlanetEvent = null): void
         {
            hasFacilities = (_buildingFacilities.length != 0);
            if (hasFacilities)
            {
               facilities.manualSelect();
               selectedConstructionModel = ML.latestPlanet.getBuildingById(selectedFacility.constructableId);
            }
            checkTheDemoThing();
         }
         
         private function removePending(e: GObjectEvent): void
         {
            waitingForApproval = false;
            if (ML.latestPlanet != null && selectedFacility != null)
            {
               selectedConstructionModel = ML.latestPlanet.getBuildingById(selectedFacility.constructableId);
               checkTheDemoThing();
            }
         }
         
         private function checkTheDemoThing(e: Event = null): void
         {
            if (selectedFacility != null)
            {
               var isConstructing: int = selectedFacility.constructableType != null? 1: 0;
               constructable.toggleToDemo((selectedFacility.constructionQueueEntries.length + isConstructing) >= 
                  (selectedFacility.maxQueryItems + 1));
            }
            else
            {
               constructable.toggleToDemo(true);
            }
         }
         
         private function refreshBonusGroup(changed: String):void
         {
            if (this[changed + "Text"] != null)
               this[changed + "BonusLabel"].visible = true
            else
               this[changed + "BonusLabel"].visible = false;
         }		
         
         /**
          * this is done when user selects building from constructable list
          **/
         private function changeConstructable(e: GSelectConstructableEvent):void{
            if (e.building == null)
            {
               selectedBuilding = null;
               deployInProgress = false;
            }
            else
            {
               selectedBuilding = e.building.type;
               deployInProgress = e.building.unitDeployed != null;
               cancelDisabled = deployInProgress;
               calculateResLeft();
            }
            dispatchBuildTimeChangeEvent();
            refreshPrice();
         }
         
         [Bindable]
         private var deployInProgress: Boolean = false;
         
         /**
          * how many seconds are left to fulfill resources needs for building
          **/
         [Bindable]
         private var resLeft: int = 0;
         
         [Bindable]
         private var enoughStorage: Boolean = true;
         
         private function refreshPrice(): void
         {
            var metal: int = deployInProgress ? 0 : getMetalPrice();
            var energy: int = deployInProgress ? 0 : getEnergyPrice();
            var zetium: int = deployInProgress ? 0 : getZetiumPrice();
            metalPrice = metal.toString();
            energyPrice = energy.toString();
            zetiumPrice = zetium.toString();
         }
         
         /**
          * thisone should be done when user presses mouse 
          * on map to confirm building construction
          * 
          * @see NewAction.as
          **/
         private function dispatchBuildingComand(e: GBuildingEvent):void{	
            if (e.building.unitDeployed == null)
            {
               new BuildingsCommand(
                  BuildingsCommand.NEW,
                  {
                     planetId: ML.latestPlanet.id,
                     x: e.building.x, y: e.building.y, 
                     type: e.building.type,
                     constructorId: selectedFacility.id}
               ).dispatch ();
            }
            else
            {
               new UnitsCommand(
                  UnitsCommand.DEPLOY,
                  {
                     planetId: ML.latestPlanet.id,
                     x: e.building.x, y: e.building.y,
                     unitId: e.building.unitDeployed.id
                  }
               ).dispatch();
               e.building.unitDeployed = null;
            }
            armorBonus = 0;
            energyBonus = 0;
            constructionBonus = 0;
            selectedBuilding = null;
            deployInProgress = false;
            waitingForApproval = true;
            constructable.deselectBuilding();
         }
         
         private function constructionCanceledHandler(e: GBuildingEvent): void
         {
            armorBonus = 0;
            energyBonus = 0;
            constructionBonus = 0;
            selectedBuilding = null;
            deployInProgress = false;
            constructable.deselectBuilding();
         }
         
         [Bindable (event = "buildTimeChanged")]
         public function get buildTime():String{
            if (selectedBuilding != null)
            {
               return DateUtil.secondsToHumanString(Upgradable.calculateUpgradeTime(
                  UpgradableType.BUILDINGS, selectedBuilding, {"level": 1},
                  (deployInProgress ? 0 : selectedFacility.constructorMod) + constructionMod
               ));
            }
            else
               return '';
         }
         
         
         public function set armorBonus(armor: int):void{
            if (armor > 0) 
               armorText = "+" + armor + "%"
            else if (armor < 0) 
               armorText = armor + "%"
            else armorText = null;	
            refreshBonusGroup("armor");
         }
         
         public function set energyBonus(energy: int):void{
            if (energy > 0) 
               energyText = "+" + energy + "%"
            else if (energy < 0) 
               energyText = energy + "%"
            else energyText = null;	
            refreshBonusGroup("energy");
         }
         
         private var constructionMod: Number;
         
         public function set constructionBonus(construction: int):void{
            if (construction > 0) 
               constructionText = "+" + construction + "%"
            else if (construction < 0) 
               constructionText = construction + "%"
            else constructionText = null;	
            constructionMod = construction;
            dispatchBuildTimeChangeEvent();
            refreshBonusGroup("construction");
         }
         
         private function dispatchBuildTimeChangeEvent(): void
         {
            dispatchEvent(new BuildingEvent(BuildingEvent.BUILD_TIME_CHANGED));
         }
         
         private function setAllBonuses(e:GBuildingMoveEvent):void{
            var bonuses: BuildingBonuses = BuildingBonuses.refreshBonuses(e.tilesUnder);
            armorBonus = bonuses.armor;
            energyBonus = bonuses.energyOutput;
            constructionBonus = bonuses.constructionTime;
         }
         
         private function cancelDrag(e: BuildingEvent): void
         {
            queueList.dropEnabled = false;
            queueList.dragMoveEnabled = false;               
            DragManager.acceptDragDrop(null);
            queueList.layout.hideDropIndicator();
            DragManager.showFeedback(DragManager.NONE);
            queueList.drawFocus(false);
         }
         
         /**
          * function that is done when facility from building
          * facilities list is selected
          **/
         protected function changeSelected(e: SelectFacilityEvent):void
         {
            if (selectedFacility != null)
            {
               selectedFacility.removeEventListener(BuildingEvent.QUERY_CHANGE, cancelDrag);
               selectedFacility.removeEventListener(BuildingEvent.QUERY_CHANGE, checkTheDemoThing);
            }
            selectedFacility = e.facility;
            if (selectedFacility != null)
            {
               selectedFacility.addEventListener(BuildingEvent.QUERY_CHANGE, cancelDrag);
               selectedFacility.addEventListener(BuildingEvent.QUERY_CHANGE, checkTheDemoThing);
            }
            selectedConstructionModel = ML.latestPlanet.getBuildingById(selectedFacility.constructableId);
            var isConstructing: int = selectedFacility.constructableType != null? 1: 0;
            constructable.toggleToDemo((selectedFacility.constructionQueueEntries.length + isConstructing) > 
               (selectedFacility.maxQueryItems + 1));
            dispatchBuildTimeChangeEvent();
         }
         
         [Bindable (event ="buildingsStatesChange")]
         private function getMetalPrice():int
         {
            if (deployInProgress)
            {
               return 0;
            }
            return Upgradable.calculateCost(UpgradableType.BUILDINGS, selectedBuilding,
               ResourceType.METAL, {"level": 1});
         }
         
         
         [Bindable (event ="buildingsStatesChange")]
         private function getEnergyPrice():int
         {
            if (deployInProgress)
            {
               return 0;
            }
            return Upgradable.calculateCost(UpgradableType.BUILDINGS, selectedBuilding,
               ResourceType.ENERGY, {"level": 1});
         }
         
         
         [Bindable (event ="buildingsStatesChange")]
         private function getZetiumPrice():int
         {
            if (deployInProgress)
            {
               return 0;
            }
            return Upgradable.calculateCost(UpgradableType.BUILDINGS, selectedBuilding,
               ResourceType.ZETIUM, {"level": 1});
         }
         
         private function handleScreenChange(e: GScreenChangeEvent): void
         {
            if (e.newScreenName != MainAreaScreens.PLANET)
            {
               if (selectedBuilding != null)
               {
                  new GSelectConstructableEvent(null);
               }
            }
            else
            {
               prepare();
            }
         }
         
         
         private function handleSidebarChange(e: GScreenChangeEvent): void
         {
            if (e.newScreenName == SidebarScreens.CONSTRUCTION)
            {
               resetBonuses();
               constructable.buildGalleryGrid();
               checkTheDemoThing();
               if (deployInProgress)
               {
                  if (cancelDisabled)
                  {
                     cancelDisabled = false;
                  }
                  else
                  {
                     new GSelectConstructableEvent(null);
                  }
               }
               refreshConstructableStates();
            }
         }         
         
         
         
         
         protected function this_creationCompleteHandler(event:FlexEvent):void
         {
            EventBroker.subscribe(GBuildingEvent.CONSTRUCTION_COMMIT, dispatchBuildingComand);
            EventBroker.subscribe(GBuildingEvent.CONSTRUCTION_CANCEL, constructionCanceledHandler);
            EventBroker.subscribe(GBuildingMoveEvent.MOVE, setAllBonuses);
            EventBroker.subscribe(GSelectConstructableEvent.BUILDING_SELECTED, changeConstructable);
            EventBroker.subscribe(GObjectEvent.OBJECT_APPROVED, removePending);
            EventBroker.subscribe(GScreenChangeEvent.SIDEBAR_CHANGE, handleSidebarChange);
            EventBroker.subscribe(GScreenChangeEvent.MAIN_AREA_CHANGED, handleScreenChange);
            EventBroker.subscribe(GBuildingEvent.OPEN, openHandler);
            EventBroker.subscribe(GPlanetEvent.BUILDINGS_CHANGE, refreshFacilities);
            EventBroker.subscribe(GPlanetEvent.PLANET_CHANGE, setFacilities);
         }
         
         
         protected function queueList_dragCompleteHandler(event:DragEvent):void
         {
            if (queueList.dragMoveEnabled)
            {
               var tempElement: ConstructionQueueEntry = (event.dragInitiator as List).selectedItems[0] as ConstructionQueueEntry;
               if (selectedFacility.constructionQueueEntries.getItemIndex(tempElement) != 
                  tempElement.position)
               {
                  var newPosition: int = tempElement.position> selectedFacility.constructionQueueEntries.getItemIndex(tempElement)? 
                     selectedFacility.constructionQueueEntries.getItemIndex(tempElement): 
                     selectedFacility.constructionQueueEntries.getItemIndex(tempElement) + 1;
                  new ConstructionQueuesCommand(
                     ConstructionQueuesCommand.MOVE,
                     {id: tempElement.id,
                        position: newPosition}
                  ).dispatch ();
               }
            }
         }
         
         protected function openHandler(e: GBuildingEvent): void
         {
            if (e.building.upgradePart.upgradeEndsAt != null || ML.latestPlanet.ssObject.owner != Owner.PLAYER)
            {
               return;
            }
            var NC: NavigationController = NavigationController.getInstance();
            if (e.building.type == BuildingType.RESEARCH_CENTER)
            {
               NC.showTechnologies();
               return;
            }
            else if (e.building.npc)
            {
               if (ML.latestPlanet.getActiveGroundUnits(Owner.PLAYER).length != 0)
               {
                  NC.showUnits(Collections.filter(ML.latestPlanet.getActiveGroundUnits(Owner.PLAYER), 
                     function(item: Unit): Boolean
                     {
                        return item.hasGuns;
                     }), ML.latestPlanet.toLocation(), e.building);
               }
               return;
            }
            else if (e.building.isConstructor(ObjectClass.UNIT))
            {
               NC.showFacilities(e.building.id);
               return;
            }
            else if (
               e.building.upgradePart.upgradeEndsAt == null && 
               e.building.state != Building.WORKING &&
               (
                  e.building.metalRate < 0 || 
                  e.building.energyRate < 0 || 
                  e.building.zetiumRate < 0
               )
            )
            {
               if (!e.building.pending)
               {
                  if (e.building.state == Building.ACTIVE)
                  {
                     new BuildingsCommand(
                        BuildingsCommand.DEACTIVATE, e.building).dispatch ();
                  }
                  else if (e.building.state == Building.INACTIVE)
                  {
                     new BuildingsCommand(
                        BuildingsCommand.ACTIVATE, e.building).dispatch ();
                  }
               }
               return;
            }
         }
         
         private var cancelDisabled: Boolean = false;
         
         private function refreshConstructableStates(e: Event = null): void
         {
            if (deployInProgress)
            {
               resLeft = 0;
               missingStorages = [];
               enoughStorage = true;
               return;
            }
            if (selectedFacility != null)
            {
               constructable.refreshBuildingsStates(selectedFacility.constructableType != null, cancelDisabled);
               dispatchBuildingStatesChangeEvent();
               if (selectedBuilding != null)
                  calculateResLeft()
               else
                  resLeft = 0;
            }
            else
            {
               constructable.refreshBuildingsStates(false, cancelDisabled);
               dispatchBuildingStatesChangeEvent();
               resLeft = 0;
            }
         }
         
         private function dispatchBuildingStatesChangeEvent(): void
         {
            dispatchEvent(new BuildingEvent(BuildingEvent.BUILDING_STATES_CHANGE));
         }
         
         private var missingStorages: Array = [];
         [Bindable]
         private var missingStorageString: String = '';
         private function calculateResLeft(): void
         {
            missingStorages = [];
            var planet:MSSObject = ML.latestPlanet.ssObject;
            if (getMetalPrice()  > planet.metal.maxStock)
            {
               missingStorages.push(ResourceType.METAL);
            }
            if (getEnergyPrice()  > planet.energy.maxStock)
            {
               missingStorages.push(ResourceType.ENERGY);
            }
            if (getZetiumPrice()  > planet.zetium.maxStock)
            {
               missingStorages.push(ResourceType.ZETIUM);
            }
            var tempStorageString: String = '';
            var i: int = 0;
            for each (var res: String in missingStorages)
            {
               if (i > 0)
               {
                  if (i == missingStorages.length - 1)
                  {
                     tempStorageString += ' '+Localizer.string('Resources', 'and')+' ';
                  }
                  else
                  {
                     tempStorageString += ', ';
                  }
               }
               i++;
               tempStorageString += Localizer.string('Resources', res);
            }
            if (missingStorageString != tempStorageString)
            {
               missingStorageString = tempStorageString;
            }
            enoughStorage = (missingStorages.length > 0?false:true);
            resLeft = Resource.getTimeToReachResources
               (planet.metal, planet.energy, planet.zetium, getMetalPrice(), getEnergyPrice(), getZetiumPrice());
         }
         
         
         protected function constructable_creationCompleteHandler(event:FlexEvent):void
         {
            EventBroker.subscribe(GResourcesEvent.RESOURCES_CHANGE, refreshConstructableStates);
            constructable.addEventListener
               (DemoChangedEvent.DEMO_SELECTION_CHANGED, handleDemoChange)
         }
         
         
         protected function queueList_dragStartHandler(event:DragEvent):void
         {
            queueList.dropEnabled = true;
            queueList.dragMoveEnabled = true;
         }
         
         private function resetBonuses(): void
         {
            armorBonus = 0;
            energyBonus = 0;
            constructionBonus = 0;
         }
         
         protected function basecontainer1_rollOverHandler(event:MouseEvent):void
         {
            resetBonuses();
         }
         
         private function getStringFromSeconds(seconds: int): String
         {
            return DateUtil.secondsToHumanString(seconds);
         }
         
         
         private function generatesEnergy(buildingType:String) : Boolean
         {
            return Building.calculateResourceGenerationRate(buildingType,
               ResourceType.ENERGY,
               {"level": 1}) > 0;
         }
         
         
         protected function queueList_creationCompleteHandler(event:FlexEvent):void
         {
            queueList.scroller.setStyle('verticalScrollPolicy', ScrollPolicy.OFF);
            queueList.scroller.setStyle('horizontalScrollPolicy', ScrollPolicy.OFF);
         }
         
      ]]>
   </fx:Script>
   
   <base:SpinnerContainer busy="{waitingForApproval}" top="0" left="0" right="0" bottom="0" timeoutEnabled="false">
      <s:Group top="0" left="0" right="0" visible="{ML.latestPlanet.ssObject.owner != Owner.PLAYER}">
         <base:Warning left="6" right="6" top="6" text="{Localizer.string ('BuildingSidebar','notYourPlanet')}"/>
      </s:Group>
      <s:Group top="0" left="0" right="0" bottom="0" visible="{ML.latestPlanet.ssObject.owner == Owner.PLAYER}">
         <base:Panel top="0" left="0" right="0" id="facilitiesPanel"
                     title="{Localizer.string ('BuildingSidebar','facilitiesTitle')}">
            <base:AdvancedContainer id="facilitiesContainer" width="100%" top="0">
               <s:Label top="5" left="10" id="noFacLabel" text="{Localizer.string ('BuildingSidebar','noFacilities')}"  
                        visible="{!hasFacilities}"/>
               <elements:BuildingFacilities id="facilities" height="{_buildingFacilities.length > 2?130:62}"
                                            visible="{hasFacilities}" creationComplete="facilities.addEventListener
                                            (SelectFacilityEvent.FACILITY_SELECTED_EVENT, changeSelected)"/>
               
               <s:Group visible="{!(!(noFacLabel.visible == false) || !(selectedFacility.constructableId != 0))}" 
                        width="100%" id="queueGroup">
                  <elements:BuildingProgressElement id="progressElement"
                                                    width="100%"
                                                    buildingModel="{selectedConstructionModel}"/>
                  <s:List id="queueList" dataProvider="{selectedFacility.constructionQueueEntries}"
                          useVirtualLayout="false"
                          width="100%" rollOverColor="#0f0f0f" selectionColor="#0f0f0f" 
                          dragEnabled="true" borderVisible="false" dragStart="queueList_dragStartHandler(event)"
                          contentBackgroundAlpha="0" creationComplete="queueList_creationCompleteHandler(event)"
                          dragComplete="queueList_dragCompleteHandler(event)"
                          height="{selectedFacility.constructionQueueEntries.length > 0?52:0}">
                     <s:itemRenderer>
                        <fx:Component>
                           <s:ItemRenderer width="100%" height="44">
                              <elements:BuildingQueryElement queryElementModel="{data}" width="100%" height="44"/>
                           </s:ItemRenderer>
                        </fx:Component>
                     </s:itemRenderer>
                     
                     <s:layout>
                        <s:TileLayout requestedColumnCount="4" verticalGap="6" horizontalGap="6"/>
                     </s:layout>
                  </s:List>
                  <s:layout>
                     <s:VerticalLayout paddingRight="7"/>
                  </s:layout>
               </s:Group>
               <base:layout>
                  <s:VerticalLayout paddingLeft="6"/>
               </base:layout>
               
            </base:AdvancedContainer>
         </base:Panel>
         
         
         <base:Panel id="constructablePanel" left="0" right="0" 
                     top="{facilitiesPanel.height + 6}" 
                     bottom="{selectedBuilding != null? bonusPanel.height+6: 0 }"
                     visible="{!noFacLabel.visible}" 
                     title="{Localizer.string ('BuildingSidebar','constructableTitle')}">
            <elements:BuildingList  left="0" right="0" top="0" bottom="0"
                                    id="constructable" constructableTypes="{ML.constructable}"
                                    creationComplete="constructable_creationCompleteHandler(event)"/>
         </base:Panel>
         
         <s:Button
            id="deselectButton"
            toolTip="{Localizer.string('BuildingSidebar','deselectButtonText')}"
            skinClass="components.skins.DeselectButtonSkin"
            right="5" 
            top="{facilitiesPanel.height + 8}"
            width="16" 
            visible="{selectedBuilding != null}" 
            height="16"
            click="constructable.deselectBuilding()"/>
         
         <base:Panel id="bonusPanel" left="0" right="0" bottom="0" 
                     title="{Localizer.string ('BuildingSidebar','infoTitle')}"
                     visible="{selectedBuilding != null}">
            <base:AdvancedContainer left="0" right="0">
               <s:Label text="{Localizer.string('BuildingSidebar','deployInProgress')}" fontWeight="bold"
                        visible="{deployInProgress}"/>
               <s:Group>
                  <s:Group width="100">
                     <base:ImageAndLabel type="{ResourceType.METAL}" textToDisplay="{metalPrice}" 
                                         labelStyleName="{getMetalPrice() > ML.latestPlanet.ssObject.metal.currentStock? 'unsatisfied':null}"
                                         toolTip="{Localizer.string('Resources', ResourceType.METAL)}"/>
                     <base:ImageAndLabel type="{ResourceType.ZETIUM}" textToDisplay="{zetiumPrice}" 
                                         labelStyleName="{getZetiumPrice() > ML.latestPlanet.ssObject.zetium.currentStock? 'unsatisfied':null}"
                                         toolTip="{Localizer.string('Resources', ResourceType.ZETIUM)}"/>
                     <s:layout>
                        <s:VerticalLayout gap="4"/>
                     </s:layout> 
                  </s:Group>
                  <s:Group width="100">
                     <base:ImageAndLabel type="{ResourceType.ENERGY}" textToDisplay="{energyPrice}" 
                                         labelStyleName="{getEnergyPrice() > ML.latestPlanet.ssObject.energy.currentStock? 'unsatisfied':null}" 
                                         toolTip="{Localizer.string('Resources', ResourceType.ENERGY)}"/>
                     <base:ImageAndLabel type="{timeIconName}" textToDisplay="{buildTime}" 
                                         toolTip="{Localizer.string('BuildingSidebar','timeToFinish')}"/>
                     <s:layout>
                        <s:VerticalLayout gap="4"/>
                     </s:layout>
                  </s:Group>
                  <s:layout>
                     <s:HorizontalLayout/>
                  </s:layout>
               </s:Group>
               
               <s:Label text="{Localizer.string('BuildingSidebar','tileBonuses')}" fontWeight="bold"
                        visible="{!((selectedBuilding == null) || 
                        !((armorText != null) || (energyText != null) || (constructionText != null))
                        )}"/>
               
               <base:AdvancedContainer id="bonusGroup" width="100%">               
                  <s:Label text="{Localizer.string('BuildingSidebar','applicable')}" fontWeight="bold"
                           paddingBottom="3"
                           visible="{!((selectedBuilding == null) || 
                           !((armorText != null) || (constructionText != null) 
                           || !((energyText == null) || !generatesEnergy(selectedBuilding)) ))}"/>
                  <elements:BonusLabel id="armorBonusLabel" type="{Localizer.string('BuildingSidebar','armor.bonus')}" ammount="{armorText}"/>
                  <elements:BonusLabel id="constructionBonusLabel" type="{Localizer.string('BuildingSidebar','construction.bonus')}" ammount="{constructionText}"/>
                  <s:Label text="{Localizer.string('BuildingSidebar','notApplicable')}" fontWeight="bold"
                           paddingBottom="3" paddingTop="3"
                           visible="{!((selectedBuilding == null) || (energyText == null) 
                           || generatesEnergy(selectedBuilding))}"/>
                  <elements:BonusLabel id="energyBonusLabel" type="{Localizer.string('BuildingSidebar','energy.bonus')}" 
                                       ammount="{energyText}"/>
                  <s:Group width="100%" visible="{resLeft != 0}">
                     <s:Label text="{Localizer.string('Resources','notEnoughResources')}" styleName="unsatisfied"
                              left="0" right="0"/>
                  </s:Group>
                  <s:Group width="100%" visible="{resLeft > 0}">
                     <s:Label text="{Localizer.string('Resources','enoughResourcesIn', [getStringFromSeconds(resLeft)])}"
                              left="0" right="0"/>  
                  </s:Group>
                  
                  <!--s:Label text="{Localizer.string('Resources','insufficientRate')}" visible="{resLeft == -1}"
                  styleName="unsatisfied"/-->
                  <s:Group width="100%" visible="{!enoughStorage}">
                     <s:Label text="{Localizer.string('Resources','additionalStorage', [missingStorageString])}" 
                              styleName="unsatisfied" left="0" right="0"/>
                  </s:Group>
                  <base:layout>
                     <s:VerticalLayout gap="1" paddingLeft="12"/>
                  </base:layout>
               </base:AdvancedContainer>
               <base:layout>
                  <s:VerticalLayout gap="6" paddingLeft="6"/>
               </base:layout>
            </base:AdvancedContainer>
         </base:Panel>
      </s:Group>
   </base:SpinnerContainer>
</base:BaseContainer>
